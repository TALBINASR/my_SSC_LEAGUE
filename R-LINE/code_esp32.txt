/*
+------------------------------------------------------------------------------+
| R-LINE1 MICROCONTROLLER CODE | DRIVE AI SYSTEM                               |
| Author: Talbi Nasr Allah                                                     |
| Created: 19/12/2025                                                          |
| ____________________________________________________________________________ |
|                                                                              |
| ALL RIGHTS RESERVED © 2025                                                   |
+------------------------------------------------------------------------------+
*/
#include <WiFi.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include <ArduinoJson.h> 
#include <U8g2lib.h> 
#define ESP32PWM_USE_TIMER_NO 3  
// --- I2C LCD CONFIGURATION ---
U8G2_ST7567_ENH_DG128064I_F_SW_I2C u8g2(U8G2_R2, /* clock=*/ 25, /* data=*/ 26, /* res=*/ U8X8_PIN_NONE);

// --- I/O PIN DEFINITIONS (ADJUST THESE) ---
#define ENA_PIN 15 
#define IN1_PIN 16  
#define IN2_PIN 4  
#define STEER_SERVO_PIN 13 

const int signalledright = 32;
const int signalledleft = 33;
const int backlights = 12;
const int frein = 14;

int ledState = LOW;
unsigned long previousMillis = 0;
const long interval = 500;

// #define PWM_CHANNEL    0
// #define PWM_FREQUENCY  5000  // 5 kHz
// #define PWM_RESOLUTION 8  

// --- SERVO PHYSICAL LIMITS (CRITICAL TUNING REQUIRED) ---
const int SERVO_MAP_MIN_DEG = 45; // Physical Servo Angle for Full Right
const int SERVO_MAP_MAX_DEG = 135; // Physical Servo Angle for Full Left

// --- WIFI CONFIGURATION (UPDATE THESE) ---
const char* ssid = "La_Fibre_dOrange_405A";
const char* password = "G2HZEN6P4TQ7AK6N7T";
const int tcpPort = 8888; 

// --- L298N PWM CONFIGURATION ---
const int freq = 30000; 
const int resolution = 8; // 0-255 duty cycle
const int pwmChannelA = 0; 

// --- GLOBAL VARIABLES ---
WiFiServer server(tcpPort);
WiFiClient client;
Servo steerServo;

// Current state variables
float currentControlAngle = 0; 
int currentThrottle = 0;
bool isClientConnected = false;

// --- CRITICAL ADDITIONS FOR ROBUST DATA HANDLING ---
char inputBuffer[128]; 
int bufferIndex = 0;
const int MAX_BUFFER_SIZE = sizeof(inputBuffer) - 1; 
char latestCompleteCommand[128]; // Buffer to hold the single latest command for processing

// --- FUNCTION PROTOTYPES ---
void setupMotorPwm();
void handleControlData(char* data);
void setMotorSpeedAndDirection(int throttle);
void setSteeringAngle(float angle);
void updateDisplay(); 
void processIncomingStream(); 
void signals(int state);

// ==============================================================================
// ----------------------------- SETUP ------------------------------------------
// ==============================================================================
u8g2_uint_t center_x(const char *s) {
  u8g2_uint_t w = u8g2.getStrWidth(s);
  return (128 - w) / 2;
}
void drawSplashScreen() {
  u8g2.clearBuffer();
  u8g2.setDrawColor(1);
  u8g2.drawBox(0, 0, 128, 64);
  u8g2.setDrawColor(0);
  
//   const char* line1 = "TALBI";
//   u8g2.setFont(u8g2_font_fub25_tf); 
//   u8g2_uint_t y1 = 35; 
//   u8g2.drawStr(center_x(line1), y1, line1);

//   const char* line2 = "AI DRIVE SYSTEMS";

  const char* line1 = "DRIVE";
  u8g2.setFont(u8g2_font_fub25_tf); 
  u8g2_uint_t y1 = 35; 
  u8g2.drawStr(center_x(line1), y1, line1);

  const char* line2 = "AI SYSTEMS";
  u8g2.setFont(u8g2_font_7x13B_tf); 
  u8g2_uint_t y2 = y1 + 18; 
  u8g2.drawStr(center_x(line2), y2, line2);
  u8g2.setDrawColor(1);
  u8g2.sendBuffer();
  // delay(2000);
}
void setup() {
    
    pinMode(signalledright,OUTPUT);
    pinMode(signalledleft,OUTPUT);
    pinMode(backlights,OUTPUT);
    pinMode(frein,OUTPUT);
    signals(3);
    Serial.begin(115200);
    delay(100);
    u8g2.setI2CAddress(0x3F * 2);
    
    // 1. Initialize LCD Display
    u8g2.begin();
    u8g2.setFont(u8g2_font_unifont_t_korean2); 
    setMotorSpeedAndDirection(0);
    digitalWrite(backlights,HIGH);
    drawSplashScreen();
    delay(2000);
    u8g2.clearBuffer();
    u8g2.drawStr(center_x("DRIVE"), 15, "DRIVE");
    u8g2.drawStr(0, 35, "Starting up...");
    u8g2.sendBuffer();

    // 2. Initialize Motor Pins and PWM
    pinMode(IN1_PIN, OUTPUT);
    pinMode(IN2_PIN, OUTPUT);
    // setupMotorPwm(); 
    
    // 3. Initialize Steering Servo
    ESP32PWM::allocateTimer(3);
    steerServo.attach(STEER_SERVO_PIN, 500, 2500); 
    // steerServo.write(90);

    // 4. Connect to Wi-Fi
    WiFi.mode(WIFI_STA);
    u8g2.setFont(u8g2_font_6x10_tf);
    u8g2.drawStr(0, 55, "Connecting server...");
    u8g2.sendBuffer();
    
    Serial.print("Connecting to Wi-Fi network: ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);

    int max_attempts = 30;
    int attempt_count = 0;
    while (WiFi.status() != WL_CONNECTED && attempt_count < max_attempts) {
        delay(500);
        Serial.print(".");
        attempt_count++;
    }
    
    // 5. Final Connection Status Display
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_tf);

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nSUCCESS: Connected to Wi-Fi.");
        String ipStr = WiFi.localIP().toString();

        u8g2.drawStr(0, 10, "SERVER: Connected");
        u8g2.drawStr(0, 25, ("IP: " + ipStr).c_str());
        
        server.begin(); 
        u8g2.drawStr(0, 40, ("Server Port: " + String(tcpPort)).c_str());
        u8g2.drawStr(0, 55, "WAITING FOR CLIENT...");
        
        Serial.print("TCP Server running on port ");
        Serial.println(("IP: " + ipStr).c_str());
    } else {
        Serial.print("\nCONNECTION FAILED! Status Code: ");
        Serial.println(WiFi.status());
        u8g2.drawStr(0, 10, "nCONNECTION FAILED!");
        signals(3);
        // u8g2.drawStr(0, 25, ("Status Code: " + String(WiFi.status())).c_str());
        // u8g2.drawStr(0, 55, "RESTART REQUIRED");
    }
    u8g2.sendBuffer();
    setMotorSpeedAndDirection(0);
    setSteeringAngle(currentControlAngle);
}


// ==============================================================================
// ------------------------------ LOOP ------------------------------------------
// ==============================================================================

void loop() {
    bool previousClientState = isClientConnected;
    // digitalWrite(backlights,HIGH);

    signals(3);

    if (!client || !client.connected()) {
        isClientConnected = false;
        if (client) {
            // Client disconnected: stop motor, reset buffer, and close connection
            setMotorSpeedAndDirection(0);
            signals(3);
            Serial.println("Client disconnected. Motor stopped. Buffer reset."); 
            client.stop();
            bufferIndex = 0; 
            signals(3);
        }
        // Listen for new clients
        WiFiClient newClient = server.available();
        if (newClient) {
            client = newClient;
            isClientConnected = true;
            Serial.println("New client connected.");
        }
    } else {
        isClientConnected = true;
    }

    if (isClientConnected) {
        processIncomingStream(); 
    if(currentControlAngle<-10){
        signals(1);
    }
    else if(currentControlAngle>10){
        signals(2);
    }
    else{
        signals(0);// The core of the speed optimization
    }
    }
    if (isClientConnected != previousClientState) {
        updateDisplay();
    }
    
   
    delay(10);
}

// ==============================================================================
// ------------------------ REVISED STREAM HANDLING FUNCTION --------------------
// ==============================================================================

void processIncomingStream() {
    bool foundCompletePacket = false;
    
    while (client.available()) {
        char c = client.read();

        // 1. Check for end of message
        if (c == '\n') {
            // Null-terminate the string in the buffer
            inputBuffer[bufferIndex] = '\0';
            
            // CRITICAL: Copy the complete packet to the dedicated 'latest' buffer
            strncpy(latestCompleteCommand, inputBuffer, MAX_BUFFER_SIZE);
            latestCompleteCommand[MAX_BUFFER_SIZE] = '\0'; 

            foundCompletePacket = true;
            
         
            bufferIndex = 0;
        } 
        
        // 2. Accumulate the character
        else if (bufferIndex < MAX_BUFFER_SIZE) {
            inputBuffer[bufferIndex] = c;
            bufferIndex++;
        }
        
        // 3. Handle buffer overflow
        else {
            // Serial.println("WARNING: TCP Buffer overflow. Discarding message."); // <-- COMMENTED FOR SPEED
            bufferIndex = 0; // Discard and reset
        }
    }
    
    // FINAL STEP: ONLY PROCESS THE LAST COMPLETE PACKET
    if (foundCompletePacket) {
        handleControlData(latestCompleteCommand);
        updateDisplay(); 
    }
}

// ==============================================================================
// ------------------------ L298N CONTROL FUNCTIONS -----------------------------
// ==============================================================================

void setupMotorPwm() {
    // ledcAttach(ENA_PIN, PWM_FREQUENCY, PWM_RESOLUTION);
    // ledcSetup(pwmChannelA, freq, resolution);
    // ledcAttachPin(ENA_PIN, pwmChannelA);
}

void setMotorSpeedAndDirection(int throttle) {
    currentThrottle = throttle;
    
    int dutyCycle = abs(throttle);
    dutyCycle = constrain(dutyCycle, 0, 255);

    if (throttle > 0) {
        digitalWrite(IN1_PIN, HIGH);
        digitalWrite(IN2_PIN, LOW);
    } else if (throttle < 0) {
        digitalWrite(IN1_PIN, LOW);
        digitalWrite(IN2_PIN, HIGH);
    } else {
        digitalWrite(IN1_PIN, LOW);
        digitalWrite(IN2_PIN, LOW);
        dutyCycle = 0;
    }
    
    analogWrite(ENA_PIN, dutyCycle);
    Serial.println(dutyCycle);
    if(throttle<50){
        digitalWrite(frein,HIGH);
    }
    else{
        digitalWrite(frein,LOW);
    }
}

// ==============================================================================
// ---------------------- STEERING (SERVO) CONTROL ------------------------------
// ==============================================================================

void setSteeringAngle(float angle) {
    currentControlAngle = angle; 

    // Normalize server input (-45 to +45)
    float normalized = (angle + 45.0) / 90.0; 

    float servoRange = (float)(SERVO_MAP_MAX_DEG - SERVO_MAP_MIN_DEG);
    // Map: -45 (Left) → Max_Deg (135), +45 (Right) → Min_Deg (45)
    float servoAngleFloat = SERVO_MAP_MAX_DEG - (normalized * servoRange);

    int servoAngle = (int)round(servoAngleFloat);
    servoAngle = constrain(servoAngle, SERVO_MAP_MIN_DEG, SERVO_MAP_MAX_DEG);

    //  Use mapped servo angle, not raw input
    steerServo.write(servoAngle);

    Serial.printf("DEBUG: Steering Input: %.2f, Mapped Servo Angle: %d\n", angle, servoAngle);
}


// ==============================================================================
// ------------------------ COMMUNICATION HANDLING ------------------------------
// ==============================================================================

void handleControlData(char* data) {
    float parsedAngle = currentControlAngle;
    int parsedThrottle = currentThrottle;
    
    // Serial.print("\n--- COMPLETE PACKET RECEIVED ---\nRaw Data: ["); // <-- COMMENTED FOR SPEED
    // Serial.print(data);                                              // <-- COMMENTED FOR SPEED
    // Serial.println("]");                                             // <-- COMMENTED FOR SPEED
    
    StaticJsonDocument<100> doc; 
    DeserializationError error = deserializeJson(doc, data);

    if (error) {
        // Serial.print("ERROR: deserializeJson() failed: "); // <-- COMMENTED FOR SPEED
        // Serial.println(error.f_str());                     // <-- COMMENTED FOR SPEED
        return; 
    }
    
    if (doc.containsKey("A") && doc.containsKey("T")) {
        parsedAngle = doc["A"].as<float>(); 
        parsedThrottle = doc["T"].as<int>();
        
        // Serial.printf("SUCCESS: Parsed Angle: %.2f, Parsed Throttle: %d\n", parsedAngle, parsedThrottle); // <-- COMMENTED FOR SPEED

        setSteeringAngle(parsedAngle);
        setMotorSpeedAndDirection(parsedThrottle);
    }
}

// ==============================================================================
// ------------------------ LCD DISPLAY FUNCTION (No Change) --------------------
// ==============================================================================

void updateDisplay() {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_tf);

    if (WiFi.status() == WL_CONNECTED) {
        String status = isClientConnected ? "SERVER: CONNECTED" : "SERVER: WAITING...";
        u8g2.drawStr(0, 10, status.c_str());
    } else {
        u8g2.drawStr(0, 10, "Wi-Fi: DISCONNECTED!");
        // u8g2.drawStr(0, 25, ("Status Code: " + String(WiFi.status())).c_str());
        u8g2.sendBuffer();
        return;
    }
    
    u8g2.drawStr(0, 25, ("IP: " + WiFi.localIP().toString()).c_str());

    String throttleLine = "T: " + String(currentThrottle) + " (";
    if (currentThrottle > 0) throttleLine += "FWD)";
    else if (currentThrottle < 0) throttleLine += "REV)";
    else throttleLine += "STOP)";
    u8g2.drawStr(0, 40, throttleLine.c_str());

    u8g2.drawStr(0, 55, ("A: " + String(currentControlAngle, 1) + " deg").c_str());

    u8g2.sendBuffer();
}
void signals(int state){
    unsigned long currentMillis = millis();
    if (currentMillis - previousMillis >= interval) {

    previousMillis = currentMillis;

    if (ledState == LOW) {
      ledState = HIGH;
    } else {
      ledState = LOW;
    }

    if(state==0){
    digitalWrite(signalledleft, 0);
    digitalWrite(signalledright, 0);    
    }
    else if(state==1){
    digitalWrite(signalledleft, ledState);    
    }
    else if(state==2){
    digitalWrite(signalledright, ledState);    
    }
    else if(state==3){
    digitalWrite(signalledleft, ledState);
    digitalWrite(signalledright, ledState);    
    }
    
  }
}