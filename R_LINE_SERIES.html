<!DOCTYPE html>
<html lang="fr">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8PH54N37D4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8PH54N37D4');
</script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R-LINE SERIES DOCUMENTATION  | TALBI</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="logo">TALBI</div>
        <ul class="nav-links" id="navLinks">
            <li><a href="index.html">Accueil</a></li>
            <li><a href="index.html#projets">Projets</a></li>
        </ul>
        <div class="burger" id="burgerMenu">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </nav>

    <div class="doc-layout container" style="margin-top: 50px;">
        <main class="doc-content">
            <h1 class="section-title" style="text-align: left;">R-LINE SERIES DOCUMENTATION</h1>
            <h3 id="v1-desc" class="doc-section">the ultimate car line</h1>
            <img src="U1.png" alt="R-Line Series Photo" class="doc-img">

            <section id="v1">
                <h2 class="version-header">R-LINE1:</h2>
                <div >
                    <h3 class="section-title">Description du projet</h3>
                    <p>
                        Le prototype R-LINE1 basé sur mon système AI DRIVE est une solution de rétrofit d'aide à la conduite (ADAS) basée sur une architecture distribuée, combinant vision par ordinateur, intelligence artificielle et contrôle embarqué.
                    </p>

                    <h4>1. Architecture Système (Hardware)</h4>
                    <ul>
                        <li><strong>Unité de Perception (Caméra)</strong> :
                            <ul>
                                <li>Composant : ESP32-CAM.</li>
                                <li>Rôle : Capture du flux vidéo en temps réel (320x240 @ 20fps).</li>
                                <li>Protocole : Stream HTTP vers l'unité de traitement.</li>
                            </ul>
                        </li>
                        <li><strong>Unité de Traitement Central (Cerveau)</strong> :
                            <ul>
                                <li>Composant : PC portable (ou unité Jetson Nano prévue pour la phase 2).</li>
                                <li>Algorithmes :
                                    <ul>
                                        <li>Vision Classique (OpenCV) : Transformation de perspective (Bird's Eye View), filtrage HSV pour la détection de lignes, et calcul d'offset par histogramme.</li>
                                        <li>Intelligence Artificielle (YOLOv8) : Modèle personnalisé entraîné pour détecter la signalisation routière (Stop, limites de vitesse, passages piétons).</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <div style="display: flex; align-items: flex-start;">
                                <div>
                                    <strong>Unité de Contrôle Actionneur (Corps)</strong> :
                                    <ul>
                                        <li>Composant : ESP32 (Standard).</li>
                                        <li>Interface : Client Socket TCP.</li>
                                        <li>Rôle : Reçoit les commandes JSON (Angle de direction et Throttle) et pilote les servomoteurs/moteurs du véhicule.</li>
                                    </ul>
                                </div>
                            </div>
                        </li>
                            <ul  >
                                <li>
                                    Composant : ESP32 (Standard).
                                    
                                </li>
                                <li>Interface : Client Socket TCP.</li>
                                <li>Rôle : Reçoit les commandes JSON (Angle de direction et Throttle) et pilote les servomoteurs/moteurs du véhicule.</li>
                            </ul>
                        </li>
                    </ul>
                    <img src="R-LINE/f5.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">

                    <h4>2. Pipeline de Traitement de l'Information (Software)</h4>
                    <p>
                        Le cycle de décision suit un processus en quatre étapes :
                    </p>
                    <ol>
                        <li><strong>Prétraitement</strong> : L'image brute subit une transformation de perspective pour obtenir une vue "du dessus" de la route, permettant une mesure précise de la déviation du véhicule par rapport au centre de la voie.</li>
                        <li><strong>Analyse de Ligne (Asservissement)</strong> :
                            <ul>
                                <li>Filtrage des pixels (Masquage HSV).</li>
                                <li>Calcul de l'erreur de trajectoire (Offset).</li>
                                <li>Application d'un Correcteur Proportionnel (P) : <span class="math">$$Angle = K_p \times Offset$$</span>.</li>
                            </ul>
                        </li>
                        <li><strong>Analyse de Signalisation (IA)</strong> : En parallèle, l'algorithme YOLO analyse les images pour identifier les panneaux. En cas de détection d'un panneau "Stop" avec une surface (Area) supérieure au seuil de sécurité, une commande de freinage d'urgence prévaut sur le suivi de ligne.</li>
                        <li><strong>Transmission</strong> : Les données sont encapsulées en JSON : {"A": angle, "T": throttle} et envoyées via Wi-Fi à l'ESP32 de contrôle avec une latence optimisée.</li>
                    </ol>
                    <img src="R-LINE/m1.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                    <img src="R-LINE/f6.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">

                    <h4>3. Spécifications du Logiciel</h4>
                    <ul>
                        <li>Langage : Python 3.x.</li>
                        <li>Bibliothèques clés :
                            <ul>
                                <li>OpenCV : Traitement d'image et interface de débogage.</li>
                                <li>Ultralytics (YOLOv8) : Inférence du modèle de détection.</li>
                                <li>NumPy : Calculs matriciels rapides.</li>
                                <li>Socket : Communication basse latence entre PC et microcontrôleurs.</li>
                            </ul>
                        </li>
                        <li>J`ai entrainer le modele AI avec une grande base des données (environ 800 images) avec des methodes d`apprentissage pour le mettre plus efficace a detecter les signes,les objets et les dangers specifiquement pour la rue marocaine:</li>
                        <div class="photo-gallery">
                            <img src="R-LINE/f1.png" class="doc-img" alt="CAD Design 1">
                            <img src="R-LINE/f2.png" class="doc-img" alt="CAD Design 2">
                            <img src="R-LINE/f3.png" class="doc-img" alt="CAD Design 3">
                            <img src="R-LINE/f4.png" class="doc-img" alt="CAD Design 4">
                            
                        </div>
                    </ul>

                    <h4>4. Innovations et Optimisations du Prototype</h4>
                    <ul>
                        <li><strong>Frame Skipping intelligent</strong> : Le suivi de ligne (critique) s'exécute sur chaque image, tandis que la détection d'objets (plus lourde) s'exécute toutes les n images pour maintenir un FPS élevé.</li>
                        <li><strong>Mode Hybride</strong> : Possibilité de basculer instantanément entre le mode autonome et le contrôle manuel par clavier pour la reprise en main d'urgence.</li>
                        <li><strong>Calibration Dynamique</strong> : Utilisation de barres de réglage (Trackbars) en temps réel pour adapter les seuils de détection aux variations de luminosité ambiante.</li>
                    </ul>
                    <img src="R1.png" alt="prototype" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                    <img src="R-LINE/p1.png" alt="prototype" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                </div>
                <div id="v1-but" class="doc-section">
                    <h3 class="section-title">But du projet</h3>
                    <p>
                        En tant qu'élève ingénieur, ma démarche avec le projet R-LINE1 dépasse la simple conception d'un prototype technologique ; 
                        elle s'inscrit dans une volonté de démocratiser la sécurité routière par l'innovation logicielle. 
                    </p>
                    <p>
                        Le but fondamental de ce projet est de concevoir un système d'assistance à la conduite (ADAS) intelligent, 
                        capable de s'adapter aux infrastructures routières complexes et changeantes, comme celles que nous rencontrons au Maroc. 
                    </p>
                    <p>
                        En exploitant la puissance de la vision par ordinateur et de l'intelligence artificielle (YOLOv8), 
                        nous visons à réduire l'erreur humaine — cause de plus de 90 % des accidents — en proposant une solution de rétrofit économiquement accessible. 
                    </p>
                    <p>
                        Ce projet constitue une preuve de concept rigoureuse démontrant que l'ingénierie peut transformer des véhicules conventionnels 
                        en entités semi-autonomes sécurisées, posant ainsi les jalons d'une mobilité intelligente, inclusive et durable.
                    </p>
                    
                </div>
                <div id="v1-meca" class="doc-section">
                    <h3 class="section-title">Conception Mécanique (CAD, apparence)</h3>

                    <div class="photo-gallery">
                        <img src="R-LINE/cad1.png" class="doc-img" alt="CAD Design 1">
                        <img src="R-LINE/cad2.png" class="doc-img" alt="CAD Design 2">
                        <img src="R-LINE/cad3.png" class="doc-img" alt="CAD Design 3">
                        <img src="R-LINE/cad4.png" class="doc-img" alt="CAD Design 4">
                        <img src="R-LINE/cad5.png" class="doc-img" alt="CAD Design 5">
                        <img src="R-LINE/cad6.png" class="doc-img" alt="CAD Design 6">
                    </div>
                        <div class="doc-container">
                            <h2 class="doc-title">Conception mécanique du prototype</h2>
                            
                            <p>La conception mécanique du prototype a été pensée pour offrir une base de test agile et fidèle aux lois de comportement d’un véhicule réel. L'objectif était de créer une plateforme robotique capable de simuler avec précision le contrôle de mouvement pour le développement de nos modèles d'IA et de futures fonctionnalités, telles que le <strong>stationnement autonome</strong>.</p>
                        
                            <h3>1. Architecture Cinématique et CAO</h3>
                            <p>Le design a été entièrement modélisé à l'aide des logiciels <strong>SolidWorks</strong> et <strong>Onshape</strong>. L'architecture retenue repose sur deux piliers :</p>
                            <ul>
                                <li><strong>Propulsion :</strong> Assurée par un moteur à courant continu (DC), permettant de simuler l'accélération et la vitesse de croisière.</li>
                                <li><strong>Direction :</strong> L’angle de braquage est piloté par un servomoteur, garantissant un contrôle angulaire précis et reproductible, indispensable pour valider les trajectoires calculées par l'algorithme de vision.</li>
                            </ul>
                        
                            <h3>2. Fabrication par Impression 3D</h3>
                            <p>Conformément à l'esprit "Maker" de l'ingénieur, la fabrication du châssis et des composants structurels a été réalisée par impression 3D (FDM) au sein du <strong>Club Mécanique Arts & Métiers de l'ENSAM</strong>. Ce choix technologique a permis :</p>
                            <ul>
                                <li>Une réduction significative de la masse globale du prototype.</li>
                                <li>Une grande flexibilité pour l'intégration des supports de capteurs (caméras, ultrasons).</li>
                                <li>Un prototypage rapide favorisant les cycles de test-correction sur le terrain.</li>
                            </ul>
                        
                            <p>Cette plateforme, bien que structurellement simple, respecte les principes dynamiques essentiels, offrant ainsi un environnement de simulation physique réaliste pour l'entraînement et le déploiement de notre intelligence artificielle.</p>
                        </div>
                    </div>
                <div id="v1-elec" class="doc-section">
                    <h3 class="section-title">Le circuit électronique</h3>
                    <div class="photo-gallery">
                        <img src="R-LINE/circuit1.png" class="doc-img" alt="CAD Design 1">
                        <img src="R-LINE/circuit3.png" class="doc-img" alt="CAD Design 2">
                        <img src="R-LINE/circuit2.png" class="doc-img" alt="CAD Design 3">
                       </div>
                </div>
                <div id="v1-code" class="doc-section">
                    <h3 class="section-title">Le code</h3>
                    <h3 id="v1-desc1" class="doc-section">Code de microcontrolleur esp32:</h1>
                        <div class="code-container">
                            <div class="code-header">
                                <span>DRIVE_AI_R-LINE1.ino</span>
                                <button class="copy-btn">Copier</button>
                            </div>
                            <pre><code>/*
                                +------------------------------------------------------------------------------+
                                | R-LINE1 MICROCONTROLLER CODE | DRIVE AI SYSTEM                               |
                                | Author: Talbi Nasr Allah                                                     |
                                | Created: 19/12/2025                                                          |
                                | ____________________________________________________________________________ |
                                |                                                                              |
                                | ALL RIGHTS RESERVED © 2025                                                   |
                                +------------------------------------------------------------------------------+
                                */
                                #include <WiFi.h>
                                #include <WebServer.h>
                                #include <ESP32Servo.h>
                                #include <ArduinoJson.h> 
                                #include <U8g2lib.h> 
                                #define ESP32PWM_USE_TIMER_NO 3  
                                // --- I2C LCD CONFIGURATION ---
                                U8G2_ST7567_ENH_DG128064I_F_SW_I2C u8g2(U8G2_R2, /* clock=*/ 25, /* data=*/ 26, /* res=*/ U8X8_PIN_NONE);
                                
                                // --- I/O PIN DEFINITIONS (ADJUST THESE) ---
                                #define ENA_PIN 15 
                                #define IN1_PIN 16  
                                #define IN2_PIN 4  
                                #define STEER_SERVO_PIN 13 
                                
                                const int signalledright = 32;
                                const int signalledleft = 33;
                                const int backlights = 12;
                                const int frein = 14;
                                
                                int ledState = LOW;
                                unsigned long previousMillis = 0;
                                const long interval = 500;
                                
                                // #define PWM_CHANNEL    0
                                // #define PWM_FREQUENCY  5000  // 5 kHz
                                // #define PWM_RESOLUTION 8  
                                
                                // --- SERVO PHYSICAL LIMITS (CRITICAL TUNING REQUIRED) ---
                                const int SERVO_MAP_MIN_DEG = 45; // Physical Servo Angle for Full Right
                                const int SERVO_MAP_MAX_DEG = 135; // Physical Servo Angle for Full Left
                                
                                // --- WIFI CONFIGURATION (UPDATE THESE) ---
                                const char* ssid = "La_Fibre_dOrange_405A";
                                const char* password = "G2HZEN6P4TQ7AK6N7T";
                                const int tcpPort = 8888; 
                                
                                // --- L298N PWM CONFIGURATION ---
                                const int freq = 30000; 
                                const int resolution = 8; // 0-255 duty cycle
                                const int pwmChannelA = 0; 
                                
                                // --- GLOBAL VARIABLES ---
                                WiFiServer server(tcpPort);
                                WiFiClient client;
                                Servo steerServo;
                                
                                // Current state variables
                                float currentControlAngle = 0; 
                                int currentThrottle = 0;
                                bool isClientConnected = false;
                                
                                // --- CRITICAL ADDITIONS FOR ROBUST DATA HANDLING ---
                                char inputBuffer[128]; 
                                int bufferIndex = 0;
                                const int MAX_BUFFER_SIZE = sizeof(inputBuffer) - 1; 
                                char latestCompleteCommand[128]; // Buffer to hold the single latest command for processing
                                
                                // --- FUNCTION PROTOTYPES ---
                                void setupMotorPwm();
                                void handleControlData(char* data);
                                void setMotorSpeedAndDirection(int throttle);
                                void setSteeringAngle(float angle);
                                void updateDisplay(); 
                                void processIncomingStream(); 
                                void signals(int state);
                                
                                // ==============================================================================
                                // ----------------------------- SETUP ------------------------------------------
                                // ==============================================================================
                                u8g2_uint_t center_x(const char *s) {
                                  u8g2_uint_t w = u8g2.getStrWidth(s);
                                  return (128 - w) / 2;
                                }
                                void drawSplashScreen() {
                                  u8g2.clearBuffer();
                                  u8g2.setDrawColor(1);
                                  u8g2.drawBox(0, 0, 128, 64);
                                  u8g2.setDrawColor(0);
                                  
                                //   const char* line1 = "TALBI";
                                //   u8g2.setFont(u8g2_font_fub25_tf); 
                                //   u8g2_uint_t y1 = 35; 
                                //   u8g2.drawStr(center_x(line1), y1, line1);
                                
                                //   const char* line2 = "AI DRIVE SYSTEMS";
                                
                                  const char* line1 = "DRIVE";
                                  u8g2.setFont(u8g2_font_fub25_tf); 
                                  u8g2_uint_t y1 = 35; 
                                  u8g2.drawStr(center_x(line1), y1, line1);
                                
                                  const char* line2 = "AI SYSTEMS";
                                  u8g2.setFont(u8g2_font_7x13B_tf); 
                                  u8g2_uint_t y2 = y1 + 18; 
                                  u8g2.drawStr(center_x(line2), y2, line2);
                                  u8g2.setDrawColor(1);
                                  u8g2.sendBuffer();
                                  // delay(2000);
                                }
                                void setup() {
                                    
                                    pinMode(signalledright,OUTPUT);
                                    pinMode(signalledleft,OUTPUT);
                                    pinMode(backlights,OUTPUT);
                                    pinMode(frein,OUTPUT);
                                    signals(3);
                                    Serial.begin(115200);
                                    delay(100);
                                    u8g2.setI2CAddress(0x3F * 2);
                                    
                                    // 1. Initialize LCD Display
                                    u8g2.begin();
                                    u8g2.setFont(u8g2_font_unifont_t_korean2); 
                                    setMotorSpeedAndDirection(0);
                                    digitalWrite(backlights,HIGH);
                                    drawSplashScreen();
                                    delay(2000);
                                    u8g2.clearBuffer();
                                    u8g2.drawStr(center_x("DRIVE"), 15, "DRIVE");
                                    u8g2.drawStr(0, 35, "Starting up...");
                                    u8g2.sendBuffer();
                                
                                    // 2. Initialize Motor Pins and PWM
                                    pinMode(IN1_PIN, OUTPUT);
                                    pinMode(IN2_PIN, OUTPUT);
                                    // setupMotorPwm(); 
                                    
                                    // 3. Initialize Steering Servo
                                    ESP32PWM::allocateTimer(3);
                                    steerServo.attach(STEER_SERVO_PIN, 500, 2500); 
                                    // steerServo.write(90);
                                
                                    // 4. Connect to Wi-Fi
                                    WiFi.mode(WIFI_STA);
                                    u8g2.setFont(u8g2_font_6x10_tf);
                                    u8g2.drawStr(0, 55, "Connecting server...");
                                    u8g2.sendBuffer();
                                    
                                    Serial.print("Connecting to Wi-Fi network: ");
                                    Serial.println(ssid);
                                    WiFi.begin(ssid, password);
                                
                                    int max_attempts = 30;
                                    int attempt_count = 0;
                                    while (WiFi.status() != WL_CONNECTED && attempt_count < max_attempts) {
                                        delay(500);
                                        Serial.print(".");
                                        attempt_count++;
                                    }
                                    
                                    // 5. Final Connection Status Display
                                    u8g2.clearBuffer();
                                    u8g2.setFont(u8g2_font_6x10_tf);
                                
                                    if (WiFi.status() == WL_CONNECTED) {
                                        Serial.println("\nSUCCESS: Connected to Wi-Fi.");
                                        String ipStr = WiFi.localIP().toString();
                                
                                        u8g2.drawStr(0, 10, "SERVER: Connected");
                                        u8g2.drawStr(0, 25, ("IP: " + ipStr).c_str());
                                        
                                        server.begin(); 
                                        u8g2.drawStr(0, 40, ("Server Port: " + String(tcpPort)).c_str());
                                        u8g2.drawStr(0, 55, "WAITING FOR CLIENT...");
                                        
                                        Serial.print("TCP Server running on port ");
                                        Serial.println(("IP: " + ipStr).c_str());
                                    } else {
                                        Serial.print("\nCONNECTION FAILED! Status Code: ");
                                        Serial.println(WiFi.status());
                                        u8g2.drawStr(0, 10, "nCONNECTION FAILED!");
                                        signals(3);
                                        // u8g2.drawStr(0, 25, ("Status Code: " + String(WiFi.status())).c_str());
                                        // u8g2.drawStr(0, 55, "RESTART REQUIRED");
                                    }
                                    u8g2.sendBuffer();
                                    setMotorSpeedAndDirection(0);
                                    setSteeringAngle(currentControlAngle);
                                }
                                
                                
                                // ==============================================================================
                                // ------------------------------ LOOP ------------------------------------------
                                // ==============================================================================
                                
                                void loop() {
                                    bool previousClientState = isClientConnected;
                                    // digitalWrite(backlights,HIGH);
                                
                                    signals(3);
                                
                                    if (!client || !client.connected()) {
                                        isClientConnected = false;
                                        if (client) {
                                            // Client disconnected: stop motor, reset buffer, and close connection
                                            setMotorSpeedAndDirection(0);
                                            signals(3);
                                            Serial.println("Client disconnected. Motor stopped. Buffer reset."); 
                                            client.stop();
                                            bufferIndex = 0; 
                                            signals(3);
                                        }
                                        // Listen for new clients
                                        WiFiClient newClient = server.available();
                                        if (newClient) {
                                            client = newClient;
                                            isClientConnected = true;
                                            Serial.println("New client connected.");
                                        }
                                    } else {
                                        isClientConnected = true;
                                    }
                                
                                    if (isClientConnected) {
                                        processIncomingStream(); 
                                    if(currentControlAngle<-10){
                                        signals(1);
                                    }
                                    else if(currentControlAngle>10){
                                        signals(2);
                                    }
                                    else{
                                        signals(0);// The core of the speed optimization
                                    }
                                    }
                                    if (isClientConnected != previousClientState) {
                                        updateDisplay();
                                    }
                                    
                                   
                                    delay(10);
                                }
                                
                                // ==============================================================================
                                // ------------------------ REVISED STREAM HANDLING FUNCTION --------------------
                                // ==============================================================================
                                
                                void processIncomingStream() {
                                    bool foundCompletePacket = false;
                                    
                                    while (client.available()) {
                                        char c = client.read();
                                
                                        // 1. Check for end of message
                                        if (c == '\n') {
                                            // Null-terminate the string in the buffer
                                            inputBuffer[bufferIndex] = '\0';
                                            
                                            // CRITICAL: Copy the complete packet to the dedicated 'latest' buffer
                                            strncpy(latestCompleteCommand, inputBuffer, MAX_BUFFER_SIZE);
                                            latestCompleteCommand[MAX_BUFFER_SIZE] = '\0'; 
                                
                                            foundCompletePacket = true;
                                            
                                         
                                            bufferIndex = 0;
                                        } 
                                        
                                        // 2. Accumulate the character
                                        else if (bufferIndex < MAX_BUFFER_SIZE) {
                                            inputBuffer[bufferIndex] = c;
                                            bufferIndex++;
                                        }
                                        
                                        // 3. Handle buffer overflow
                                        else {
                                            // Serial.println("WARNING: TCP Buffer overflow. Discarding message."); // <-- COMMENTED FOR SPEED
                                            bufferIndex = 0; // Discard and reset
                                        }
                                    }
                                    
                                    // FINAL STEP: ONLY PROCESS THE LAST COMPLETE PACKET
                                    if (foundCompletePacket) {
                                        handleControlData(latestCompleteCommand);
                                        updateDisplay(); 
                                    }
                                }
                                
                                // ==============================================================================
                                // ------------------------ L298N CONTROL FUNCTIONS -----------------------------
                                // ==============================================================================
                                
                                void setupMotorPwm() {
                                    // ledcAttach(ENA_PIN, PWM_FREQUENCY, PWM_RESOLUTION);
                                    // ledcSetup(pwmChannelA, freq, resolution);
                                    // ledcAttachPin(ENA_PIN, pwmChannelA);
                                }
                                
                                void setMotorSpeedAndDirection(int throttle) {
                                    currentThrottle = throttle;
                                    
                                    int dutyCycle = abs(throttle);
                                    dutyCycle = constrain(dutyCycle, 0, 255);
                                
                                    if (throttle > 0) {
                                        digitalWrite(IN1_PIN, HIGH);
                                        digitalWrite(IN2_PIN, LOW);
                                    } else if (throttle < 0) {
                                        digitalWrite(IN1_PIN, LOW);
                                        digitalWrite(IN2_PIN, HIGH);
                                    } else {
                                        digitalWrite(IN1_PIN, LOW);
                                        digitalWrite(IN2_PIN, LOW);
                                        dutyCycle = 0;
                                    }
                                    
                                    analogWrite(ENA_PIN, dutyCycle);
                                    Serial.println(dutyCycle);
                                    if(throttle<50){
                                        digitalWrite(frein,HIGH);
                                    }
                                    else{
                                        digitalWrite(frein,LOW);
                                    }
                                }
                                
                                // ==============================================================================
                                // ---------------------- STEERING (SERVO) CONTROL ------------------------------
                                // ==============================================================================
                                
                                void setSteeringAngle(float angle) {
                                    currentControlAngle = angle; 
                                
                                    // Normalize server input (-45 to +45)
                                    float normalized = (angle + 45.0) / 90.0; 
                                
                                    float servoRange = (float)(SERVO_MAP_MAX_DEG - SERVO_MAP_MIN_DEG);
                                    // Map: -45 (Left) → Max_Deg (135), +45 (Right) → Min_Deg (45)
                                    float servoAngleFloat = SERVO_MAP_MAX_DEG - (normalized * servoRange);
                                
                                    int servoAngle = (int)round(servoAngleFloat);
                                    servoAngle = constrain(servoAngle, SERVO_MAP_MIN_DEG, SERVO_MAP_MAX_DEG);
                                
                                    //  Use mapped servo angle, not raw input
                                    steerServo.write(servoAngle);
                                
                                    Serial.printf("DEBUG: Steering Input: %.2f, Mapped Servo Angle: %d\n", angle, servoAngle);
                                }
                                
                                
                                // ==============================================================================
                                // ------------------------ COMMUNICATION HANDLING ------------------------------
                                // ==============================================================================
                                
                                void handleControlData(char* data) {
                                    float parsedAngle = currentControlAngle;
                                    int parsedThrottle = currentThrottle;
                                    
                                    // Serial.print("\n--- COMPLETE PACKET RECEIVED ---\nRaw Data: ["); // <-- COMMENTED FOR SPEED
                                    // Serial.print(data);                                              // <-- COMMENTED FOR SPEED
                                    // Serial.println("]");                                             // <-- COMMENTED FOR SPEED
                                    
                                    StaticJsonDocument<100> doc; 
                                    DeserializationError error = deserializeJson(doc, data);
                                
                                    if (error) {
                                        // Serial.print("ERROR: deserializeJson() failed: "); // <-- COMMENTED FOR SPEED
                                        // Serial.println(error.f_str());                     // <-- COMMENTED FOR SPEED
                                        return; 
                                    }
                                    
                                    if (doc.containsKey("A") && doc.containsKey("T")) {
                                        parsedAngle = doc["A"].as<float>(); 
                                        parsedThrottle = doc["T"].as<int>();
                                        
                                        // Serial.printf("SUCCESS: Parsed Angle: %.2f, Parsed Throttle: %d\n", parsedAngle, parsedThrottle); // <-- COMMENTED FOR SPEED
                                
                                        setSteeringAngle(parsedAngle);
                                        setMotorSpeedAndDirection(parsedThrottle);
                                    }
                                }
                                
                                // ==============================================================================
                                // ------------------------ LCD DISPLAY FUNCTION (No Change) --------------------
                                // ==============================================================================
                                
                                void updateDisplay() {
                                    u8g2.clearBuffer();
                                    u8g2.setFont(u8g2_font_6x10_tf);
                                
                                    if (WiFi.status() == WL_CONNECTED) {
                                        String status = isClientConnected ? "SERVER: CONNECTED" : "SERVER: WAITING...";
                                        u8g2.drawStr(0, 10, status.c_str());
                                    } else {
                                        u8g2.drawStr(0, 10, "Wi-Fi: DISCONNECTED!");
                                        // u8g2.drawStr(0, 25, ("Status Code: " + String(WiFi.status())).c_str());
                                        u8g2.sendBuffer();
                                        return;
                                    }
                                    
                                    u8g2.drawStr(0, 25, ("IP: " + WiFi.localIP().toString()).c_str());
                                
                                    String throttleLine = "T: " + String(currentThrottle) + " (";
                                    if (currentThrottle > 0) throttleLine += "FWD)";
                                    else if (currentThrottle < 0) throttleLine += "REV)";
                                    else throttleLine += "STOP)";
                                    u8g2.drawStr(0, 40, throttleLine.c_str());
                                
                                    u8g2.drawStr(0, 55, ("A: " + String(currentControlAngle, 1) + " deg").c_str());
                                
                                    u8g2.sendBuffer();
                                }
                                void signals(int state){
                                    unsigned long currentMillis = millis();
                                    if (currentMillis - previousMillis >= interval) {
                                
                                    previousMillis = currentMillis;
                                
                                    if (ledState == LOW) {
                                      ledState = HIGH;
                                    } else {
                                      ledState = LOW;
                                    }
                                
                                    if(state==0){
                                    digitalWrite(signalledleft, 0);
                                    digitalWrite(signalledright, 0);    
                                    }
                                    else if(state==1){
                                    digitalWrite(signalledleft, ledState);    
                                    }
                                    else if(state==2){
                                    digitalWrite(signalledright, ledState);    
                                    }
                                    else if(state==3){
                                    digitalWrite(signalledleft, ledState);
                                    digitalWrite(signalledright, ledState);    
                                    }
                                    
                                  }
                                }</code></pre>
                        </div> 
                     <h3 id="v1-desc2" class="doc-section">Code de traitement avec AI:</h1>
                            <div class="code-container">
                                <div class="code-header">
                                    <span>DRIVE_AI_R-LINE1.py</span>
                                    <button class="copy-btn">Copier</button>
                                </div>
                                <pre><code>
                                    /*
                                    +------------------------------------------------------------------------------+
                                    | R-LINE1 AI DRIVE CODE | DRIVE AI SYSTEM                               |
                                    | Author: Talbi Nasr Allah                                                     |
                                    | Created: 19/12/2025                                                          |
                                    | ____________________________________________________________________________ |
                                    |                                                                              |
                                    | ALL RIGHTS RESERVED © 2025                                                   |
                                    +------------------------------------------------------------------------------+
                                    */
                                    import cv2
                                    import numpy as np
                                    import time
                                    import socket
                                    import json
                                    from ultralytics import YOLO
                                    import platform
                                    
                                    # --- COMMUNICATION CONFIGURATION ---
                                    
                                    ESP32_IP = "192.168.11.106"
                                    ESP32_PORT = 8888
                                    COMM_TIMEOUT = 0.5
                                    
                                    # --- CAMERA AND IMAGE CONFIGURATION ---
                                    CAMERA_URL = "http://192.168.11.103/stream"
                                    FRAME_WIDTH = 320
                                    FRAME_HEIGHT = 240
                                    
                                    # --- PERFORMANCE OPTIMIZATION ---
                                    
                                    ML_FRAME_SKIP = 5
                                    frame_counter = 0
                                    
                                    # --- CONTROL AND TUNING PARAMETERS (Line Following) ---
                                    STEERING_KP = 1.2
                                    MAX_STEERING_ANGLE = 45
                                    BASE_THROTTLE = 130
                                    
                                    # --- MANUAL CONTROL PARAMETERS ---
                                    MANUAL_STEERING_STEP = 5
                                    MANUAL_THROTTLE_STEP = 10
                                    MAX_MANUAL_THROTTLE = 180
                                    MIN_MANUAL_THROTTLE = 0
                                    
                                    manual_steering = 0.0
                                    manual_throttle = 0
                                    control_mode = 'manual'
                                    
                                    src_points = np.float32([
                                        [100, 150], [220, 150], [300, 230], [20, 230]
                                    ])
                                    dst_points = np.float32([
                                        [50, 0], [270, 0], [270, FRAME_HEIGHT], [50, FRAME_HEIGHT]
                                    ])
                                    M = cv2.getPerspectiveTransform(src_points, dst_points)
                                    Minv = cv2.getPerspectiveTransform(dst_points, src_points)
                                    
                                    # --- ML DETECTION CONFIGURATION ---
                                    MODEL_PATH = 'D:/R-LINE PRO/runs/detect/traffic_sign_detector_v1/weights/best.pt'
                                    CONFIDENCE_THRESHOLD = 0.5
                                    SIGN_CLASSES = {
                                        0: "Stop",
                                        1: "crosswalk",
                                        2: "no_stopping",
                                        3: "speed_limit",
                                    }
                                    MAX_SIGN_AREA_TO_STOP = 5000
                                    SPEED_LIMIT_THROTTLE = 110
                                    
                                    client_socket = None
                                    ml_model = None
                                    last_detected_signs = []
                                    
                                    # --- COMMUNICATION FUNCTIONS ---
                                    
                                    def setup_socket_client():
                                        global client_socket
                                        try:
                                            print(f"Attempting to connect to ESP32 at {ESP32_IP}:{ESP32_PORT}...")
                                            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                                            client_socket.settimeout(COMM_TIMEOUT)
                                            client_socket.connect((ESP32_IP, ESP32_PORT))
                                            print("SUCCESS: Connected to ESP32!")
                                            return True
                                        except socket.error as e:
                                            client_socket = None
                                            return False
                                    
                                    def send_control_data(angle, throttle):
                                        global client_socket
                                        if client_socket is None:
                                            return
                                    
                                        try:
                                            data = {"A": round(-angle, 2), "T": int(throttle)}
                                            message = json.dumps(data) + '\n'
                                            client_socket.sendall(message.encode('utf-8'))
                                        except socket.error as e:
                                            print(f"WARNING: Lost connection to ESP32: {e}. Attempting to reconnect...")
                                            client_socket.close()
                                            client_socket = None
                                            setup_socket_client()
                                            return
                                    
                                    # --- VISION PROCESSING FUNCTIONS (Line Detection) ---
                                    
                                    def warp_perspective(img):
                                        warped = cv2.warpPerspective(img, M, (FRAME_WIDTH, FRAME_HEIGHT), flags=cv2.INTER_LINEAR)
                                        return warped
                                    
                                    def get_color_threshold(img):
                                        h_min = cv2.getTrackbarPos("H_Min", "Control Panel")
                                        h_max = cv2.getTrackbarPos("H_Max", "Control Panel")
                                        s_min = cv2.getTrackbarPos("S_Min", "Control Panel")
                                        s_max = cv2.getTrackbarPos("S_Max", "Control Panel")
                                        v_min = cv2.getTrackbarPos("V_Min", "Control Panel")
                                        v_max = cv2.getTrackbarPos("V_Max", "Control Panel")
                                        
                                        lower_bound = np.array([h_min, s_min, v_min])
                                        upper_bound = np.array([h_max, s_max, v_max])
                                    
                                        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                                        mask = cv2.inRange(hsv, lower_bound, upper_bound)
                                        return mask
                                    
                                    def calculate_control_signals(binary_warped):
                                        y_start = int(FRAME_HEIGHT * 3 / 4)
                                        histogram = np.sum(binary_warped[y_start:,:], axis=0)
                                        debug_warped = cv2.cvtColor(binary_warped, cv2.COLOR_GRAY2BGR)
                                    
                                        midpoint = np.int32(histogram.shape[0] / 2)
                                        MIN_PIXEL_COUNT = 50
                                    
                                        left_peak_candidate = np.argmax(histogram[:midpoint])
                                        leftx_base = left_peak_candidate if histogram[left_peak_candidate] > MIN_PIXEL_COUNT else FRAME_WIDTH // 4
                                    
                                        right_peak_candidate = np.argmax(histogram[midpoint:]) + midpoint
                                        rightx_base = right_peak_candidate if histogram[right_peak_candidate] > MIN_PIXEL_COUNT else FRAME_WIDTH * 3 // 4
                                    
                                        lane_center_x = (leftx_base + rightx_base) / 2
                                        image_center_x = FRAME_WIDTH / 2
                                        offset_x = lane_center_x - image_center_x
                                    
                                        auto_steering_angle = STEERING_KP * offset_x
                                        auto_steering_angle = max(-MAX_STEERING_ANGLE, min(MAX_STEERING_ANGLE, auto_steering_angle))
                                    
                                        auto_throttle = BASE_THROTTLE
                                    
                                        line_color = (0, 255, 255)
                                        
                                        cv2.line(debug_warped, (leftx_base, FRAME_HEIGHT), (leftx_base, FRAME_HEIGHT-30), line_color, 2)
                                        cv2.line(debug_warped, (rightx_base, FRAME_HEIGHT), (rightx_base, FRAME_HEIGHT-30), line_color, 2)
                                    
                                        cv2.circle(debug_warped, (int(lane_center_x), FRAME_HEIGHT - 10), 5, (0, 0, 255), -1)
                                    
                                        arrow_origin = (int(image_center_x), FRAME_HEIGHT)
                                        arrow_tip_x = int(image_center_x + offset_x * 0.7)
                                        arrow_tip_y = FRAME_HEIGHT - 40
                                        arrow_tip = (arrow_tip_x, arrow_tip_y)
                                        
                                        cv2.line(debug_warped, (int(image_center_x), FRAME_HEIGHT), (int(image_center_x), 0), (128, 128, 128), 1)
                                        
                                        cv2.arrowedLine(debug_warped, arrow_origin, arrow_tip, (255, 0, 0), 4, tipLength=0.3)
                                        
                                        return auto_steering_angle, auto_throttle, debug_warped, offset_x
                                    
                                    # --- MACHINE LEARNING FUNCTIONS (Unchanged) ---
                                    
                                    def load_ml_model():
                                        global ml_model
                                        try:
                                            ml_model = YOLO(MODEL_PATH)
                                            print(f"SUCCESS: Loaded YOLOv8 model from {MODEL_PATH}")
                                        except Exception as e:
                                            print(f"ERROR: Failed to load YOLOv8 model. Check MODEL_PATH and dependencies. {e}")
                                            ml_model = None
                                    
                                    def draw_signs_on_frame(signs_list, debug_frame):
                                        for sign_type, sign_area, box_coords, conf in signs_list:
                                            x1, y1, x2, y2 = box_coords
                                            
                                            color = (0, 255, 0) if sign_type == "Stop" else (255, 255, 0)
                                            cv2.rectangle(debug_frame, (x1, y1), (x2, y2), color, 2)
                                            label = f"{sign_type} {conf:.2f} ({sign_area})"
                                            cv2.putText(debug_frame, label, (x1, y1 - 10), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                                                
                                        return debug_frame
                                    
                                    def detect_traffic_signs_ml(frame):
                                        if ml_model is None:
                                            return []
                                    
                                        detected_signs = []
                                        
                                        results = ml_model(frame, conf=CONFIDENCE_THRESHOLD, verbose=False, device='cpu', stream=True)
                                    
                                        for r in results:
                                            boxes = r.boxes
                                            for box in boxes:
                                                x1, y1, x2, y2 = map(int, box.xyxy[0])
                                                conf = float(box.conf[0])
                                                cls = int(box.cls[0])
                                                
                                                sign_type = SIGN_CLASSES.get(cls, f"Class_{cls}")
                                                sign_area = (x2 - x1) * (y2 - y1)
                                                box_coords = (x1, y1, x2, y2)
                                                
                                                detected_signs.append((sign_type, sign_area, box_coords, conf))
                                                
                                        return detected_signs
                                    
                                    # --- TRACKBAR CONTROL WINDOW SETUP (Unchanged) ---
                                    def empty(a):
                                        pass
                                    
                                    def create_control_panel():
                                        cv2.namedWindow("Control Panel", cv2.WINDOW_NORMAL)
                                        cv2.resizeWindow("Control Panel", 400, 300)
                                    
                                        cv2.createTrackbar("H_Min", "Control Panel", 0, 179, empty)
                                        cv2.createTrackbar("H_Max", "Control Panel", 179, 179, empty)
                                        cv2.createTrackbar("S_Min", "Control Panel", 0, 255, empty)
                                        cv2.createTrackbar("S_Max", "Control Panel", 255, 255, empty)
                                        cv2.createTrackbar("V_Min", "Control Panel", 0, 255, empty)
                                        cv2.createTrackbar("V_Max", "Control Panel", 50, 255, empty)
                                        
                                        placeholder = np.zeros((300, 400, 3), dtype=np.uint8)
                                        cv2.putText(placeholder, "Tuning Panel Ready", (50, 150), 
                                                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
                                        cv2.imshow("Control Panel", placeholder)
                                    
                                    # --- KEYBOARD HANDLER FUNCTION ---
                                    def handle_keyboard_input(key_pressed, auto_steering):
                                        global manual_steering, manual_throttle, control_mode, MAX_STEERING_ANGLE, MAX_MANUAL_THROTTLE, MIN_MANUAL_THROTTLE
                                        
                                        if key_pressed == ord('m') or key_pressed == ord('M'):
                                            if control_mode == 'auto':
                                                control_mode = 'manual'
                                                manual_throttle = BASE_THROTTLE
                                                manual_steering = 0.0
                                                # print("Mode switched to MANUAL (Keyboard Control)")
                                            else:
                                                control_mode = 'auto'
                                                manual_throttle = 0
                                                manual_steering = 0.0
                                                # print("Mode switched to AUTO (Line Follow)")
                                            return
                                        
                                        if control_mode == 'manual':
                                            if key_pressed == 81:
                                                manual_steering = max(-MAX_STEERING_ANGLE, manual_steering - MANUAL_STEERING_STEP)
                                            elif key_pressed == 83:
                                                manual_steering = min(MAX_STEERING_ANGLE, manual_steering + MANUAL_STEERING_STEP)
                                            
                                            elif key_pressed == 82:
                                                manual_throttle = min(MAX_MANUAL_THROTTLE, manual_throttle + MANUAL_THROTTLE_STEP)
                                            elif key_pressed == 84:
                                                manual_throttle = max(MIN_MANUAL_THROTTLE, manual_throttle - MANUAL_THROTTLE_STEP)
                                            
                                            elif key_pressed == 32:
                                                manual_steering = 0.0
                                                manual_throttle = 0
                                            elif key_pressed == 13:
                                                manual_steering = 0.0
                                    
                                    # --- MAIN LOOP ---
                                    
                                    def main():
                                        global frame_counter, last_detected_signs, BASE_THROTTLE, manual_steering, manual_throttle, control_mode
                                        
                                        create_control_panel()
                                        load_ml_model()
                                        setup_socket_client()
                                        
                                        cap = cv2.VideoCapture(CAMERA_URL, cv2.CAP_FFMPEG)
                                        cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
                                        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
                                        
                                        cap.set(cv2.CAP_PROP_BUFFERSIZE, 2)
                                    
                                        ret, frame = (True, np.ones((FRAME_HEIGHT, FRAME_WIDTH, 3), dtype=np.uint8) * 255)
                                        is_dummy = True
                                        if cap.isOpened():
                                            ret, frame = cap.read()
                                            is_dummy = not ret
                                            if ret:
                                                print(f"SUCCESS: Connected to camera stream at {CAMERA_URL}")
                                        else:
                                            print(f"ERROR: Could not open camera stream at {CAMERA_URL}.")
                                            BASE_THROTTLE = 0
                                    
                                        auto_steering_angle = 0.0
                                        prev_time = time.time()
                                    
                                        while cap.isOpened() or is_dummy:
                                            current_time = time.time()
                                            fps = 1.0 / (current_time - prev_time)
                                            prev_time = current_time
                                    
                                            if not is_dummy:
                                                ret, frame = cap.read()
                                    
                                            if not ret:
                                                time.sleep(0.01)
                                                continue
                                            
                                            frame_counter += 1
                                            frame = cv2.resize(frame, (FRAME_WIDTH, FRAME_HEIGHT))
                                            
                                            binary_lines = get_color_threshold(frame)
                                            warped_lines = warp_perspective(binary_lines)
                                            
                                            auto_steering_angle, base_throttle, debug_warped, offset_x = calculate_control_signals(warped_lines)
                                            
                                            debug_signs_frame = frame.copy()
                                            current_detected_signs = []
                                            current_sign_action = "N/A"
                                    
                                            if ml_model is not None:
                                                if frame_counter % ML_FRAME_SKIP == 0 and control_mode == 'auto':
                                                    current_detected_signs = detect_traffic_signs_ml(frame)
                                                    last_detected_signs = current_detected_signs
                                                    
                                                current_detected_signs = last_detected_signs
                                                debug_signs_frame = draw_signs_on_frame(current_detected_signs, debug_signs_frame)
                                    
                                            final_steering = 0.0
                                            final_throttle = 0
                                            
                                            if control_mode == 'auto':
                                                final_steering = auto_steering_angle
                                                final_throttle = base_throttle
                                                # current_sign_action = "Line Follow"
                                    
                                                for sign_type, sign_area, _, _ in current_detected_signs:
                                                    if sign_type == "Stop":
                                                        if sign_area > MAX_SIGN_AREA_TO_STOP:
                                                            final_throttle = 0
                                                            final_steering = 0
                                                            current_sign_action = f"STOPPED ({sign_area})"
                                                            break
                                                        else:
                                                            final_throttle = min(final_throttle, SPEED_LIMIT_THROTTLE)
                                                            current_sign_action = f"Approaching STOP ({sign_area})"
                                    
                                                    elif sign_type == "speed_limit":
                                                        final_throttle = min(final_throttle, SPEED_LIMIT_THROTTLE)
                                                        current_sign_action = f"Speed Limit (40km/h)"
                                    
                                                    elif sign_type in ["no_stopping", "crosswalk"]:
                                                        final_throttle = min(final_throttle, SPEED_LIMIT_THROTTLE)
                                                        current_sign_action = f"CAUTION: {sign_type} ({final_throttle})"
                                    
                                            else:
                                                final_steering = manual_steering
                                                final_throttle = manual_throttle
                                                # current_sign_action = "N/A (MANUAL)"
                                    
                                            send_control_data(final_steering, final_throttle)
                                    
                                            control_text = np.zeros((FRAME_HEIGHT, FRAME_WIDTH, 3), dtype=np.uint8)
                                            
                                            mode_color = (0, 255, 0) if control_mode == 'auto' else (0, 0, 255)
                                            cv2.putText(control_text, f"Mode (M key): {control_mode.upper()}", (10, 30), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, mode_color, 2)
                                            cv2.putText(control_text, f"FPS: {fps:.1f}", (10, 60), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
                                    
                                            cv2.putText(control_text, f"FINAL Steering: {final_steering:.2f} deg", (10, 100), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
                                            cv2.putText(control_text, f"FINAL Throttle: {final_throttle}", (10, 130), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
                                            
                                            cv2.putText(control_text, f"AUTO Angle: {auto_steering_angle:.2f} deg", (10, 160), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 150, 255), 1)
                                    
                                            cv2.putText(control_text, f"ML Action: {current_sign_action}", (10, 190), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
                                            
                                            cv2.putText(control_text, "Keys: M=Toggle | Arrows=Control", (10, 230), 
                                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                                            
                                            line_debug_frame = cv2.warpPerspective(debug_warped, Minv, (FRAME_WIDTH, FRAME_HEIGHT), flags=cv2.INTER_LINEAR)
                                            
                                            top_row = np.hstack((debug_signs_frame, line_debug_frame))
                                            bottom_row = np.hstack((debug_warped, control_text))
                                            combined_view = np.vstack((top_row, bottom_row))
                                    
                                            cv2.imshow('Autonomous Car Debug View', combined_view)
                                    
                                            key = cv2.waitKey(1) & 0xFF
                                            if key == ord('q'):
                                                break
                                            
                                            if key != 255:
                                                handle_keyboard_input(key, auto_steering_angle)
                                            
                                            if is_dummy:
                                                cv2.waitKey(0)
                                                break
                                    
                                        send_control_data(0, 0)
                                    
                                        if client_socket:
                                            client_socket.close()
                                            print("Socket closed.")
                                        if cap.isOpened() and not is_dummy:
                                            cap.release()
                                        cv2.destroyAllWindows()
                                        print("Application closed.")
                                    
                                    if __name__ == "__main__":
                                        main()</code></pre>
                            </div> 
                        
                </div>
            </section>

            <hr class="doc-sep">
<!-- ------------------------------------------------------------------------------------------------------------------- -->
            <section id="v2">
                <h2  id="v2-desc" class="version-header">R-LINE2:</h2>
                <div>
                    <h3 class="section-title">Description du projet</h3>
                    <p>
                        Conception complète et optimisation technique d'un véhicule télécommandé à l'échelle, axée sur la performance dynamique et la fabricabilité par impression 3D. Ce projet combine ingénierie mécanique assistée par ordinateur (<strong>CAO</strong>), dynamique des fluides (<strong>CFD</strong>) et <strong>mécatronique</strong>.
                    </p>
                
                    <hr>
                    <img src="R-LINE/m5.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
   
                    <h3>Spécifications Techniques</h3>
                
                    <div>
                        <h4>1. Chaîne Cinématique & Propulsion (4x4 Powertrain)</h4>
                        <ul>
                            <li><strong>Transmission Intégrale (AWD) :</strong> Système de transmission aux quatre roues pour une motricité optimale.</li>
                            <li><strong>Motorisation :</strong> Double motorisation DC couplée, offrant un couple élevé et une réponse rapide.</li>
                            <li><strong>Différentiel Arrière :</strong> Conception d'un différentiel à pignons coniques fonctionnel pour améliorer la tenue de route en virage et réduire l'usure des pneumatiques.</li>
                            <li><strong>Réduction Mécanique :</strong> Système d'engrenages optimisé pour équilibrer la vitesse de pointe et le couple de démarrage.</li>
                        </ul>
                    </div>
                    <img src="R-LINE/m4.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                    <div>
                        <h4>2. Direction & Maniabilité</h4>
                        <ul>
                            <li><strong>Servo-Direction :</strong> Intégration d'un servomoteur pour un contrôle précis de l'angle de braquage.</li>
                            <li><strong>Géométrie de Direction :</strong> Conception basée sur le principe d'Ackermann pour assurer un roulement parfait sans glissement latéral des roues avant lors des virages.</li>
                        </ul>
                    </div>
                    <img src="R-LINE/m3.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                    <div>
                        <h4>3. Conception Dynamique & Aérodynamisme</h4>
                        <ul>
                            <li><strong>Châssis Optimisé :</strong> Structure rigide accueillant une batterie LiPo 3S (11.1V), avec une répartition des masses centrée pour une meilleure stabilité.</li>
                            <li><strong>Étude CFD (Computational Fluid Dynamics) :</strong> Analyse des flux d'air sur la carrosserie pour minimiser le coefficient de traînée (C<sub>x</sub>) et maximiser l'appui aérodynamique (Downforce) via l'aileron arrière et le diffuseur frontal.</li>
                            <li><strong>Design R-LINE :</strong> Carrosserie aérodynamique avec prises d'air fonctionnelles pour le refroidissement des composants internes.</li>
                        </ul>
                    </div>
                    <img src="R-LINE/m1.png" alt="ESP32" class="doc-img2" style=" border-radius: 10px; border: 2px solid var(--primary-orange); ">
                    <div>
                        <h4>4. Conception pour la Fabrication (DfAM)</h4>
                        <ul>
                            <li><strong>Outils CAO :</strong> Utilisation experte de SolidWorks et Onshape pour la modélisation paramétrique et l'assemblage (plus de 50 composants uniques).</li>
                            <li><strong>Préparation Impression 3D :</strong> Optimisation des tolérances mécaniques pour l'assemblage (ajustements serrés/glissants) et orientation des pièces pour maximiser la résistance structurelle des couches.</li>
                        </ul>
                    </div>
                <div id="v2-but" class="doc-section">
                    <h3 class="section-title">But du projet</h3>
                    <ul>
                        <li>
                            <strong>Ingénierie Mécanique :</strong> 
                            Concevoir une chaîne de transmission intégrale (4x4) fonctionnelle incluant un différentiel arrière pour garantir une dynamique de conduite réaliste.
                        </li>
                        <li>
                            <strong>Optimisation Aérodynamique :</strong> 
                            Valider les formes de la carrosserie par simulation fluide (CFD) afin d'équilibrer l'esthétique et la performance (réduction de traînée et appui).
                        </li>
                        <li>
                            <strong>Intégration Mécatronique :</strong> 
                            Optimiser l'implantation des composants électroniques (moteurs DC, servo, batterie LiPo 3S) au sein d'un châssis compact et rigide.
                        </li>
                        <li>
                            <strong>Fabrication :</strong> 
                            Appliquer les principes de "Design for Manufacturing" pour une production finale par impression 3D.
                        </li>
                    </ul>
                    
                </div>
            </div>
                <div id="v2-meca" class="doc-section">
                    <h3 class="section-title">Conception Mécanique (CAD, apparence)</h3>

                    <div class="photo-gallery">
                        <img src="R-LINE/cad7.png" class="doc-img" alt="CAD Design 1">
                        <img src="R-LINE/cad8.png" class="doc-img" alt="CAD Design 2">
                        <img src="R-LINE/cad9.png" class="doc-img" alt="CAD Design 3">
                        <img src="R-LINE/cad10.png" class="doc-img" alt="CAD Design 4">
                        <!-- <img src="R-LINE/cad.png" class="doc-img" alt="CAD Design 5">
                        <img src="R-LINE/cad.png" class="doc-img" alt="CAD Design 6"> -->
                    </div>
                        <div class="doc-container">
                            <h2 class="doc-title">Conception mécanique du prototype</h2>
                            
                            <p>La conception mécanique du prototype a été pensée pour offrir une base de test agile et fidèle aux lois de comportement d’un véhicule réel. L'objectif était de créer une plateforme robotique capable de simuler avec précision le contrôle de mouvement pour le développement de nos modèles d'IA et de futures fonctionnalités, telles que le <strong>stationnement autonome</strong>.</p>
                        
                            <h3>1. Architecture Cinématique et CAO</h3>
                            <p>Le design a été entièrement modélisé à l'aide des logiciels <strong>SolidWorks</strong> et <strong>Onshape</strong>. L'architecture retenue repose sur deux piliers :</p>
                            <ul>
                                <li><strong>Propulsion :</strong> Assurée par un moteur à courant continu (DC), permettant de simuler l'accélération et la vitesse de croisière.</li>
                                <li><strong>Direction :</strong> L’angle de braquage est piloté par un servomoteur, garantissant un contrôle angulaire précis et reproductible, indispensable pour valider les trajectoires calculées par l'algorithme de vision.</li>
                            </ul>
                        
                            <h3>2. Fabrication par Impression 3D</h3>
                            <p>Conformément à l'esprit "Maker" de l'ingénieur, la fabrication du châssis et des composants structurels a été réalisée par impression 3D (FDM) au sein du <strong>Club Mécanique Arts & Métiers de l'ENSAM</strong>. Ce choix technologique a permis :</p>
                            <ul>
                                <li>Une réduction significative de la masse globale du prototype.</li>
                                <li>Une grande flexibilité pour l'intégration des supports de capteurs (caméras, ultrasons).</li>
                                <li>Un prototypage rapide favorisant les cycles de test-correction sur le terrain.</li>
                            </ul>
                        
                            <p>Cette plateforme, bien que structurellement simple, respecte les principes dynamiques essentiels, offrant ainsi un environnement de simulation physique réaliste pour l'entraînement et le déploiement de notre intelligence artificielle.</p>
                        </div>
                    
                </div>
                
            </section>
        </main>

        <aside class="doc-sidebar">
            <div class="sticky-index">
                <h4>Index</h4>
                <ul class="index-list">
                    <li><strong href="#v1-desc">R-LINE1</strong>
                        <ul>
                            <li><a href="#v1-desc">Description</a></li>
                            <li><a href="#v1-but">But</a></li>
                            <li><a href="#v1-meca">Mécanique</a></li>
                            <li><a href="#v1-elec">Électronique</a></li>
                            <li><a href="#v1-code">Code</a></li>
                        </ul>
                    </li>
                    <li style="margin-top:20px"><strong href="#v2-desc">R-LINE2</strong>
                        <ul>
                            <li><a href="#v2-desc">Description</a></li>
                            <li><a href="#v2-but">But</a></li>
                            <li><a href="#v2-meca">Mécanique</a></li>
                            
                        </ul>
                    </li>
                </ul>
            </div>
        </aside>
    </div>
    <footer class="main-footer">
        <div class="footer-container">
            <div class="footer-logo">
                TALBI <span>NASR ALLAH</span>
            </div>
            <p class="footer-tagline">Élève Ingénieur ENSAM | Spécialiste en Systèmes Embarqués & Mécanique</p>
            
            <div class="footer-socials">
                <a href="https://www.linkedin.com/in/nasr-allah-talbi-77899232b?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=android_app" target="_blank" title="LinkedIn">
                    <i class="fab fa-linkedin"></i> LinkedIn
                </a>
                <a href="https://github.com/TALBINASR" target="_blank" title="GitHub">
                    <i class="fab fa-github"></i> GitHub
                </a>
                <a href="https://www.instagram.com/talbinassr?igsh=MWhtdDB4emsya2Mxdg==" target="_blank" title="Instagram">
                    <i class="fab fa-instagram"></i> Instagram
                </a>
                <a href="talbynassro@email.com" title="Email">
                    <i class="fas fa-envelope"></i> talbynassro@email.com
                </a>
            </div>
    
            <div class="footer-bottom">
                <p>&copy; 2026 TALBI NASR ALLAH. Tous droits réservés.</p>
                <p>ENSAM - Arts & Métiers</p>
            </div>
        </div>
    </footer>
    <script>// 1. ANIMATION DU LOGO (ANIME.JS)

    // 1. ANIMATION LOGO
    const logo = document.querySelector('.logo');
    if (logo) {
        const letters = logo.textContent.split("");
        logo.innerHTML = letters.map(char => `<span>${char === " " ? "&nbsp;" : char}</span>`).join("");
        anime({
            targets: '.logo span',
            translateY: [{ value: '-1.7rem', easing: 'easeOutExpo', duration: 600 }, { value: 0, easing: 'easeOutBounce', duration: 800, delay: 100 }],
            rotate: { value: '-1turn', delay: 0 },
            delay: anime.stagger(50), 
            easing: 'easeInOutCirc',
            loop: true
        });
    }

    // 2. MENU MOBILE (BURGER)
    const burger = document.getElementById('burgerMenu');
    const nav = document.getElementById('navLinks');

    if (burger && nav) {
        burger.addEventListener('click', () => {
            nav.classList.toggle('active');
            burger.classList.toggle('toggle');
        });

        document.querySelectorAll('.nav-links a').forEach(link => {
            link.addEventListener('click', () => {
                nav.classList.remove('active');
                burger.classList.remove('toggle');
            });
        });
    }

    // 3. COPIE DU CODE
    document.querySelectorAll('.copy-btn').forEach(button => {
        button.addEventListener('click', function() {
            const container = this.closest('.code-container');
            if (container) {
                const code = container.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    const originalText = this.innerText;
                    this.innerText = "Copié !";
                    this.style.color = "#ff8c00";
                    setTimeout(() => {
                        this.innerText = originalText;
                        this.style.color = "";
                    }, 2000);
                });
            }
        });
    });

    // 4. BACK TO TOP
    const backToTopButton = document.getElementById("backToTop");
    if (backToTopButton) {
        window.onscroll = function() {
            if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                backToTopButton.style.display = "block";
            } else {
                backToTopButton.style.display = "none";
            }
        };
        backToTopButton.addEventListener("click", () => {
            window.scrollTo({ top: 0, behavior: "smooth" });
        });
    }

    </script>
    <script>
        // Uniquement pour la page documentation
        const burgerMenu = document.getElementById('burgerMenu');
        const navLinks = document.getElementById('navLinks');
        const sidebar = document.querySelector('.doc-sidebar');
    
        if (window.innerWidth < 800 && sidebar) {
            // On clone l'index dans le menu mobile s'il existe
            const indexClone = sidebar.cloneNode(true);
            navLinks.appendChild(indexClone);
        }
    </script>
</body>
</html>